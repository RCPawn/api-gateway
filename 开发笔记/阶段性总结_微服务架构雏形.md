### 🏢 核心角色大图谱

我们将整个微服务架构想象成一家 **“现代化大公司”**：

#### 1. Nacos (注册中心 & 配置中心)

- **角色**：**人力资源部 (HR) + 公司公告栏**。
- **职责**：
  - **注册 (Registry)**：每个服务（员工）入职（启动）时，都要去 HR 那里登记自己的工位号（IP:Port）。
  - **发现 (Discovery)**：谁想找“订单部”办事，先问 HR：“订单部在哪？”，HR 返回一份名单。
  - **配置 (Config)**：老板制定了新规矩（比如限流规则），写在“公告栏”上。员工（Gateway）会实时盯着公告栏，一旦有变动立马执行，不需要重启。

#### 2. API Gateway (网关)

- **角色**：**公司大门保安室 & 前台**。
- **职责**：
  - **路由 (Routing)**：客户（外部请求）来了，保安看了一眼要去哪里（Path），指引他去“A栋3楼”（转发给对应服务）。
  - **鉴权 (Auth)**：保安检查客户有没有工牌（Token），没有就不让进。
  - **去前缀 (StripPrefix)**：客户只知道叫“/demo/hello”，保安把“/demo”去掉，告诉内部员工“他要找 /hello”。

#### 3. Sentinel (哨兵)

- **角色**：**交通指挥员 & 熔断器**。
- **职责**：
  - **限流 (Flow Control)**：大门口人太多了？Sentinel 拦住一部分：“大家排队，每秒只能进 5 个人！”（保护网关不被冲垮）。
  - **持久化 (Persistence)**：指挥员手里的规则手册（JSON）是由 HR（Nacos）保管的，不管指挥员换班（重启）多少次，手册内容永远是最新的。

#### 4. OpenFeign (远程调用)

- **角色**：**内部对讲机**。
- **职责**：
  - **声明式调用**：员工 A 想找员工 B 办事，不需要亲自跑腿，只需要拿起对讲机喊一声（调用接口方法）。
  - **直连**：对讲机通过 HR（Nacos）拿到了员工 B 的频率，直接通话，**不经过大门口保安（Gateway）**。

#### 5. Service Provider / Consumer (微服务)

- **角色**：**具体干活的员工**。
- **职责**：处理业务逻辑，通过对讲机（Feign）互相协作。

------

```plaintext
[客户端]
   ↓ (带Token)
[API Gateway :9000]
   ├─ AuthGlobalFilter (校验Token)
   ├─ DynamicRouteLoader (路由转发)
   └─ Sentinel (限流)
   ↓
[Nacos服务发现]
   ↓
[Service Consumer :8083]
   ├─ UserInfoInterceptor (提取userId)
   ├─ ConsumerController
   └─ ProviderClient (Feign调用)
   ↓
[Service Provider :8081]
   └─ HelloController (业务处理)
```

### 🔄 它们是如何配合运作的？

为了看清全貌，我们梳理两条最核心的链路。

#### 场景一：外部用户访问接口 (User -> Gateway -> Provider)

1. **启动阶段**：
   - Provider 启动，告诉 Nacos：“我在 8081 端口”。
   - Gateway 启动，从 Nacos 拉取 Provider 的地址列表。
   - Gateway 从 Nacos 拉取 Sentinel 的限流规则。
2. **请求阶段**：
   - **用户** 发起请求 http://gateway:9000/demo/hello?token=123。
   - **Gateway (Sentinel)**：先看限流规则。每秒超过 5 个了吗？超过了直接踢回，没超过放行。
   - **Gateway (Filter)**：检查 Header 里有 Token 吗？没有踢回。
   - **Gateway (LoadBalancer)**：我要找 service-provider，Nacos 给了我 3 个地址，我挑一个（轮询）。
   - **Gateway (Forward)**：把请求修剪为 /hello，转发给选中的 Provider。
   - **Provider**：处理业务，返回结果。

#### 场景二：服务内部调用 (Consumer -> Feign -> Provider)

*注意：这个过程完全不经过 Gateway！*

1. **调用阶段**：
   - Consumer 的代码里执行 providerClient.callHello()。
2. **Feign 解析**：
   - Feign 看到 @FeignClient("service-provider")。
   - Feign 问 Nacos：“service-provider 有哪些 IP？”
   - Nacos 返回：[192.168.1.5:8081, 192.168.1.6:8081]。
3. **负载均衡**：
   - Feign 内部的 LoadBalancer 挑一个 IP。
4. **发起请求**：
   - Feign 拼接真实 URL：http://192.168.1.5:8081/hello（注意：这里用的真实路径，没加 /demo 前缀）。
   - 发送 HTTP 请求，拿到结果。

------



### 📝 核心关系总结表

| 组件关系                | 描述                                                | 关键配置点                               |
| ----------------------- | --------------------------------------------------- | ---------------------------------------- |
| **Gateway ↔ Nacos**     | 网关去 Nacos 找后端服务 IP；网关去 Nacos 拿限流配置 | discovery.server-addr, datasource.nacos  |
| **Gateway ↔ Sentinel**  | 网关集成 Sentinel SDK，实现流量拦截                 | rule-type: gw-flow, resource-mode        |
| **Gateway ↔ Provider**  | 网关转发请求给后端（需注意路径前缀）                | predicates: Path, filters: StripPrefix   |
| **Feign ↔ Nacos**       | Feign 去 Nacos 找目标服务 IP                        | @FeignClient(value="服务名")             |
| **Consumer ↔ Provider** | 消费者通过 Feign **直连** 提供者                    | 接口路径必须匹配 Provider 的**真实路径** |

------



### 🌟 你的学习成就

你现在的进度非常完美：

1. **基础设施** (Nacos) ✅
2. **流量入口** (Gateway) ✅
3. **安全屏障** (Auth + Sentinel) ✅
4. **规则持久化** (Nacos Config) ✅
5. **内部通信** (OpenFeign) ✅

这已经是一个微服务架构的**最小闭环 (MVP)** 了。如果你去面试，这套架构的设计思路和踩坑经验（比如 Feign 路径问题、Sentinel 规则丢失问题、JDK 版本问题）都是非常高价值的加分项！

接下来你可以稍作休息，或者开始考虑业务逻辑的填充（比如连接数据库 MySQL、MyBatis-Plus 等），那都是后话了。祝贺你！🚀