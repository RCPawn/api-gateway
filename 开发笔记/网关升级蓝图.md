
---

### 📊 一、 当前进度状态 (Status Report)

**后端核心 (Backend Core)**
*   [x] **基础架构**：Nacos + Gateway + Provider + Consumer (已完成)
*   [x] **通信闭环**：ThreadLocal + Feign 拦截器实现 Token/UserID 全链路透传 (核心难点已攻克)
*   [x] **流量治理**：Sentinel 限流熔断 + 规则持久化 (已完成)
*   [x] **动态路由**：基于 Nacos 监听器实现路由热更新 (已完成)
*   [x] **API 文档**：Knife4j 聚合文档 + 网关自文档 (已完成)
*   [x] **管理接口**：RouteController 实现对 Nacos 配置的读写 (已完成)
*   [ ] **Redis 基础**：RedisTemplate 配置与工具类封装 (待启动)
*   [ ] **高级安全**：防重放攻击过滤器 (待启动)

**前端可视化 (Frontend Visualization)**
*   [x] **架构搭建**：Vue 3 + Vite + Element Plus (已完成)
*   [x] **路由列表**：展示路由信息、断言与过滤器 (已完成)
*   [x] **路由管理**：**实现路由的新增、编辑、删除与实时生效** (已完成，里程碑)
*   [ ] **流量驾驶舱**：ECharts 展示 QPS/CPU/内存图表 (待启动)
*   [ ] **限流配置**：可视化修改 Sentinel 规则 (待启动)

**当前系统评级**：⭐⭐⭐⭐⭐ (全栈管理闭环已打通，正在向“高安全、高可观测”进阶)

---

### 🗺️ 二、 优化后的升级路线图 (Roadmap 6.0)

**核心策略**：先补齐后端的 Redis 能力（提升简历含金量），再回头做前端的“面子工程”（图表与限流配置）。

#### 🥇 第一优先级：Redis 基础设施与安全 (Backend Security) —— *本次目标*
*   **目标**：引入 Redis，实现分布式环境下的基础能力与安全防护。
*   **价值**：面试必问 Redis 使用场景，这是最直接的实战案例。
*   **动作**：
    1.  **基础设施**：启用 Redis 配置，封装 `RedisUtils` (set, get, expire)。
    2.  **防重放攻击 (Replay Attack)**：编写 `GlobalFilter`，利用 `Nonce + Timestamp` 机制，配合 Redis 有效期，拦截重复请求。

#### 🥈 第二优先级：流量驾驶舱 (Dashboard Metrics)
*   **目标**：让首页动起来，展示系统的“生命体征”。
*   **动作**：
    1.  **后端**：确保 `/actuator/metrics` 等端点可用。
    2.  **前端**：引入 **ECharts**。
    3.  **图表实现**：
        *   **仪表盘**：展示 JVM 内存使用率。
        *   **折线图**：展示网关实时的 QPS (通过 Sentinel 或 Actuator 获取)。

#### 🥉 第三优先级：限流规则管理 (Rate Limit UI)
*   **目标**：把 Nacos 里的 `gateway-sentinel-rule.json` 可视化。
*   **动作**：
    1.  **后端**：编写 `SentinelController`，参考 `RouteController` 的逻辑，实现对 Sentinel 规则 JSON 的读写。
    2.  **前端**：新增“限流配置”菜单，用表格展示资源名、阈值，提供“编辑阈值”的弹窗。

---

### 👉 三、 下一步做什么？ (Next Step)

**任务代号：Redis 回归与防重放实战**

请按以下顺序执行，搞定后你的网关安全性将提升一个档次：

#### 🛠️ 步骤 1：基础设施复活
1.  **修改 `pom.xml`**：确保 `spring-boot-starter-data-redis-reactive` 依赖存在（注意是 reactive 版本，因为网关是 WebFlux）。
2.  **修改 `application.yml`**：把之前注释掉的 Redis 配置放开。
3.  **编写 `RedisConfig`**：配置序列化规则（防止乱码）。
4.  **编写 `RedisUtils`**：封装简单的 `set(key, value, time)`, `hasKey(key)` 方法。

#### 🛠️ 步骤 2：防重放过滤器 (ReplayAttackFilter) 原理预习
*面试常考题：如何防止黑客截获请求包重复发送？*

**逻辑流程**：
1.  前端发请求时，Header 需带上：
    *   `nonce`：一个随机字符串（UUID）。
    *   `timestamp`：当前时间戳。
2.  **网关过滤器拦截**：
    *   **检查时间**：`timestamp` 与服务器时间差是否超过 5 分钟？（超过直接拒，防止太久以前的包）。
    *   **检查 Redis**：查 `nonce` 是否存在？
        *   **存在**：说明是重复请求 -> **拦截 (403)**。
        *   **不存在**：说明是新请求 -> **放行**，并把 `nonce` 存入 Redis，过期时间设为 5 分钟。

---

**准备好了吗？我们先去把 Redis 跑起来，这是做高级安全功能的地基！**