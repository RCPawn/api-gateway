
---

### 🟢 第一维：宏观链路追踪 (上帝视角)

**目标**：不看具体代码，先在脑子里建立数据流动的“高速公路”。

**方法**：**日志分析法**。
请把你之前在 `Consumer`、`Provider`、`Gateway` 里写的 `System.out.println` 全部打开，然后发一个请求，观察控制台的日志打印顺序。

**你需要验证的顺序（心流）：**
1.  **网关收到**：`AuthGlobalFilter` 打印日志（Token 校验通过）。
2.  **网关防重放**：`ReplayAttackFilter` 打印日志（Nonce 检查通过）。
3.  **Consumer 拦截**：`UserInfoInterceptor` 打印（Header -> ThreadLocal）。
4.  **Consumer 业务**：Controller 打印（准备调 Feign）。
5.  **Feign 发送**：`FeignTokenInterceptor` 打印（ThreadLocal -> Header）。
6.  **Provider 接收**：`HelloController` 打印（Header 接收成功）。

### 🎨 最终满分版流程描述

> 1.  **请求到达**：客户端发起请求到达网关。
> 2.  **路由匹配**：网关根据 URL 匹配到 Nacos 中的路由规则（如 `/consumer/**`）。
> 3.  **网关过滤链**：
>     *   **ReplayAttackFilter**：校验 Nonce/Timestamp 防重放。
>     *   **AuthGlobalFilter**：校验 Token，解析 UserID，**修改 Header**。
>     *   **LoadBalancer**：负载均衡选出一个实例 IP。
> 4.  **网关转发**：由 Netty 异步发送请求给 Consumer 服务。
> 5.  **Consumer 入口**：**UserInfoInterceptor** 拦截，读取 Header，存入 **ThreadLocal**。
> 6.  **Consumer 业务**：执行 Controller 逻辑，发起 Feign 调用。
> 7.  **Feign 出口**：**FeignTokenInterceptor** 拦截，**从 ThreadLocal 取出 Token**，注入 Feign 请求头。
> 8.  **Provider 入口**：**UserInfoInterceptor** 再次拦截，读取 Header，存入 ThreadLocal。
> 9.  **Provider 业务**：成功获取 UserID，执行业务逻辑。

---

### 🔵 第二维：微观代码解剖 (外科手术)

**目标**：搞懂每一行代码为什么这么写，变量里到底存了什么。

**方法**：**断点调试法 (Debug)**。这是最高效的学习手段，没有之一。

请在以下 **4 个关键位置** 打上红点（断点），然后发起请求，一步步按 `F8` (Step Over) 和 `F7` (Step Into) 走。

#### 1. 核心断点 A：`AuthGlobalFilter.java`
*   **位置**：`filter` 方法的第一行。
*   **观察**：
    *   看 `exchange` 变量：里面有什么？URI 是什么？Header 长什么样？
    *   看 `chain.filter(exchange)`：当代码走到这一行时，你可以想象请求“飞”出去了。
    *   **思考**：为什么这里用 `Mono`？如果我在这里 `return null` 会发生什么？

#### 2. 核心断点 B：`DynamicRouteListener.java`
*   **操作**：启动网关，然后在 Nacos 网页上修改路由配置并发布。
*   **位置**：`receiveConfigInfo(String configInfo)` 方法内部。
*   **观察**：
    *   当你在 Nacos 点“发布”的一瞬间，IDEA 会突然卡在断点上。**这就是长轮询的回调！**
    *   看 `configInfo` 字符串：是不是你刚才在 Nacos 写的那段 JSON？
    *   **思考**：它是怎么变成网关路由的？（跟进 `dynamicRouteService.refresh` 里面看）。

#### 3. 核心断点 C：`FeignTokenInterceptor.java` (Consumer端)
*   **位置**：`apply` 方法内部。
*   **观察**：
    *   查看 `UserContext.getToken()`：这时候里面有值吗？（验证 ThreadLocal 是否生效）。
    *   查看 `template` 对象：这是 Feign 马上要发出的请求，看看它的 Header 里是不是空的？执行完 `template.header(...)` 后再看，是不是加上了？

---

### 🔴 第三维：框架源码穿透 (通过现象看本质)

**目标**：搞懂 Spring Cloud Gateway 底层是怎么配合你工作的。

这不是通读源码，而是**“顺藤摸瓜”**。

#### 1. 路由是怎么匹配的？
*   **入口**：你写了 `predicates: Path=/demo/**`。
*   **源码探索**：按 `Ctrl + N` 搜索 **`RoutePredicateHandlerMapping`** 类。
    *   这是网关的“调度中心”。
    *   打个断点在 `getHandlerInternal` 方法。
    *   发请求，你会发现它在遍历所有的 Route，一个个试你的 Predicate（断言），直到找到匹配的那个。

#### 2. 过滤器链是怎么串起来的？
*   **入口**：你实现了 `GlobalFilter`。
*   **源码探索**：搜索 **`FilteringWebHandler`** 类。
    *   看 `handle` 方法。你会发现它把所有的 GlobalFilter 和 RouteFilter 加到一个 List 里，排好序，然后生成了一个链条。
    *   这就是为什么你写 `chain.filter` 就能调到下一个过滤器的原因。

---

### 📚 具体的执行计划

花 **2 个晚上**，按这个顺序执行：

**第 1 晚：攻克“数据流”**
1.  在 `AuthGlobalFilter`、`UserInfoInterceptor`、`FeignTokenInterceptor` 打断点。
2.  发起一个完整的全链路请求。
3.  **盯着变量看**：Header 是怎么一点点变多，Token 是怎么从 Request -> ThreadLocal -> Request 变来变去的。
4.  **感悟**：这就是“全链路身份闭环”的物理形态。

**第 2 晚：攻克“控制流”**
1.  在 `DynamicRouteListener` 打断点。
2.  去 Nacos 改配置。
3.  **盯着 JSON 看**：看字符串是怎么被 Jackson 解析成 `GatewayRouteEntity`，又是怎么被转化成 `RouteDefinition` 的。
4.  **感悟**：这就是“动态路由”和“Nacos 监听”的物理形态。

---

### 💡 遇到看不懂的代码怎么办？

1.  **AI 解释**：选中那段代码，问 AI “这段代码的每一行在做什么？为什么要用这个类？”
2.  **改代码破坏它**：比如把 `chain.filter` 删掉，看看请求会怎样？（会卡死）。把 `ThreadLocal.remove` 删掉，看看会有什么隐患？（虽然很难复现内存泄漏，但能逼自己思考）。
