// 👇【核心修复】明确指定表名，防止它乱转译
@TableName("gateway_log")
---

### 1. 为什么要防重放？（防的是什么？）

**场景：** 你给女朋友转账 100 块钱。
**正常流程：**
1.  你点击发送 -> 请求发出 `{"to": "gf", "money": 100}`。
2.  服务端收到 -> 扣你 100 块 -> 交易结束。

**黑客攻击（重放）：**
1.  黑客截获了你的这个请求数据包。
2.  虽然黑客**解密不开**数据（因为有 HTTPS），但他知道这个包是有效的。
3.  黑客拿着这个数据包，**疯狂向你的服务器发送了 10 次**。
4.  **后果**：服务器以为是你自己发起的请求，于是处理了 10 次。**你莫名其妙被扣了 1000 块钱！**

**结论：防重放，防的就是“合法请求被恶意重复发送”。**

---

### 2. 那个 ID 是什么？（绝不是用户 ID！）

**误区纠正**：这个 ID **绝对不是** 用户 ID。
如果限制了用户 ID 不能重复，那你这辈子只能调一次接口，第二次就报错了，这显然不对。

**正解**：这个 ID 叫 **Nonce (Number used ONCE)**，意思是**“只用一次的随机串”**。
*   它是前端发请求时生成的**唯一流水号**（通常是 UUID）。
*   **每一次** 点击按钮，前端都会生成一个新的 UUID。
*   **作用**：它代表了**“这一次特定的请求动作”**，而不是代表“你这个人”。

---

### 3. 为什么要限制 5 分钟？（Timestamp 的作用）

你可能会问：**“既然有了 Nonce 唯一 ID，我把所有请求的 ID 都存进 Redis，下次来了查一下有没有不就行了吗？为什么要加时间限制？”**

**因为 Redis 存不下！**
*   假设你的系统运行了 10 年，有几十亿次请求。
*   如果你不限制时间，你就得把这几十亿个 UUID 全部存在 Redis 里永久保存。**Redis 会直接爆满**。

**巧妙的“时间窗口”设计：**
我们要防的，通常是短时间内的恶意重放。
*   我们规定：**请求必须是“新鲜”的（比如 5 分钟内）。**
*   **如果请求时间戳是 5 分钟前的** -> 直接根据 Timestamp 拒绝（太老了，我看都不看）。
*   **如果请求时间戳是 5 分钟内的** -> 我再去查 Redis 里的 Nonce。

**这样做的好处：**
Redis 只需要存**最近 5 分钟**的 Nonce！过期了就自动删除。
这极大地节省了 Redis 的内存空间。

---

### 🛡️ 完整的防御逻辑闭环

**黑客想攻击你，他面临两个选择：**

1.  **立刻重放（5分钟内）**：
    *   黑客：复制数据包，马上发过去。
    *   网关：时间戳校验通过 -> 查 Redis -> **发现 Nonce 已存在** -> **拦截！**

2.  **等会儿再重放（5分钟后）**：
    *   黑客：等了 10 分钟再发。
    *   网关：**一看时间戳是 10 分钟前的** -> **直接拦截！**（根本不用查 Redis）。

3.  **篡改时间戳和 Nonce**：
    *   黑客：那我把时间戳改新，把 Nonce 改掉？
    *   网关：**签名校验失败！**（这是下一步要做的高级安全，前端会把参数+时间+Nonce算一个签名，改了任何一个，签名就不对了）。

### 📝 总结

*   **防重放** = **防止别人复印你的支票去取钱**。
*   **Nonce** = **支票上的唯一流水号**（不是你的身份证号）。
*   **Timestamp** = **支票的有效期**（为了不让银行账本太厚，过期的支票直接作废，不需要去查流水号）。



---

### 1. 代码层面：设定的“倒计时”

 `ReplayAttackFilter.java`，注意这行代码：

```java
// 第三个参数 300，就是秒数 (5分钟)
return redisUtil.set(nonce, "1", 300)
        .flatMap(success -> chain.filter(exchange));
```

 `RedisUtil.java`：

```java
public Mono<Boolean> set(String key, String value, long time) {
    // Duration.ofSeconds(time) 这里把 300 转换成了有效期
    return reactiveRedisTemplate.opsForValue()
            .set(key, value, Duration.ofSeconds(time));
}
```

**发生了什么？**
当你执行这行代码时，你实际上是对 Redis 发送了一条命令：
`SET test-uuid-1111 "1" EX 300`

*   **EX 300** 的意思是：这条数据只能活 **300 秒**。
*   **300 秒一到，Redis 会自动把它删掉**，完全不需要你写代码去删。

---

### 2. Redis 内部层面：它是什么时候删除的？

你问：“它是什么时候删除的，固定的吗？”
**答案：逻辑上是固定的（300秒准时失效），但物理删除有一点点“偷懒”机制。**

Redis 采用的是 **惰性删除 + 定期删除** 相结合的方式：

#### A. 惰性删除 (Lazy Expiration) —— “查的时候才删”
*   **场景**：虽然 300 秒已经过了，但 Redis 可能还没来得及清理这个 key（它还在内存里）。
*   **触发**：万一这时候黑客又发了这个 Nonce 过来，你的代码调用 `redisUtil.hasKey(nonce)` 去查。
*   **动作**：Redis 刚要读这个 key，发现：“哎哟，这数据设置了过期时间，而且已经超时了！”
*   **结果**：Redis **立刻把它删掉**，然后告诉你的代码：“没查到，不存在。”（对你来说，效果就是已经删了）。

#### B. 定期删除 (Active Expiration) —— “后台偷偷删”
*   **场景**：如果这个过期 key 没人来查，难道就一直占着内存吗？
*   **动作**：Redis 会每隔 100ms 随机抽取一些设置了过期时间的 key，检查它们有没有过期。如果过期了，就当场删除。
*   **结果**：通过这种方式，保证过期的 key 最终都会被清理掉，释放内存。

---

### 3. 为什么“5分钟策略”天衣无缝？

结合 **Java 代码逻辑** 和 **Redis 过期机制**，我们形成了一个完美的闭环：

*   **0 ~ 5 分钟内**：
    *   如果不存 Redis，黑客重放会成功。
    *   存了 Redis，黑客重放时查到 key 存在 -> **拦截**。
*   **5 分钟后**：
    *   Redis 里的 key 自动删除了（查不到了）。
    *   这时候黑客重放，Redis 查不到，岂不是放行了？
    *   **不会！** 因为你的 Java 代码第一步就是校验 `Timestamp`。
    *   **Java 代码一看时间戳是 5 分钟前的 -> 直接拦截。**

**结论：**
*   Redis 负责守住 **“新鲜的重复请求”**。
*   Timestamp 负责守住 **“陈旧的重复请求”**。
*   它俩配合，Redis 里永远只需要存最近 5 分钟的数据，**内存占用极小且固定**，哪怕你运行 100 年，Redis 也不会爆满。

这一切的魔法都在那个 **`300`** 秒参数里！